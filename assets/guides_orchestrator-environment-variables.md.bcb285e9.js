import{_ as s}from"./chunks/fake-dev-instance-monitor-running.e3224c6d.js";import{_ as n,c as i,a as e,b as o,t as d,d as c,e as t,o as l,r as h}from"./app.dabbfae6.js";const C=JSON.parse('{"title":"Orchestrator Environment Variables","description":"","frontmatter":{"title":"Orchestrator Environment Variables"},"headers":[{"level":2,"title":"Required","slug":"required","link":"#required","children":[]},{"level":2,"title":"Recommended","slug":"recommended","link":"#recommended","children":[{"level":3,"title":"Orchestrator Instance ID","slug":"orchestrator-instance-id","link":"#orchestrator-instance-id","children":[]},{"level":3,"title":"Orchestrator Run Groups","slug":"orchestrator-run-groups","link":"#orchestrator-run-groups","children":[]}]},{"level":2,"title":"Optional: Orchestrator Behaviour","slug":"optional-orchestrator-behaviour","link":"#optional-orchestrator-behaviour","children":[]},{"level":2,"title":"Optional: Monitor Configuration","slug":"optional-monitor-configuration","link":"#optional-monitor-configuration","children":[]}],"relativePath":"guides/orchestrator-environment-variables.md","lastUpdated":1670289166000}'),p={name:"guides/orchestrator-environment-variables.md"},u={id:"frontmatter-title",tabindex:"-1"},m=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),_=t(`<p>We recommend the use of a secrets manager; however, in our documentation we use basic syntax and presume you\u2019ll have a preferred method for protecting your env vars.</p><h2 id="required" tabindex="-1">Required <a class="header-anchor" href="#required" aria-hidden="true">#</a></h2><p>At a minimum, Metrist Orchestrator must know your API token (which you can get from <a href="https://app.metrist.io/profile" target="_blank" rel="noreferrer">app.metrist.io/profile</a>).</p><p>When you follow our <a href="/guides/orchestrator-installation.html">guided installation</a>, the script prompts you for the key if it finds that <code>METRIST_API_TOKEN</code> is empty in your environment.</p><p>You may want to define the variable explicitly, as follows:</p><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">export</span><span style="color:#A6ACCD;"> METRIST_API_TOKEN=your_token</span></span>
<span class="line"></span></code></pre></div><h2 id="recommended" tabindex="-1">Recommended <a class="header-anchor" href="#recommended" aria-hidden="true">#</a></h2><p>If you\u2019ve already installed Orchestrator, you may have noticed the Metrist monitor in your dashboard receives, by default, telemetry data to a region called <code>fake-dev-instance</code>. This is configurable, see below:</p><p><img src="`+s+`" alt="Metrist monitor telemetry example"></p><h3 id="orchestrator-instance-id" tabindex="-1">Orchestrator Instance ID <a class="header-anchor" href="#orchestrator-instance-id" aria-hidden="true">#</a></h3><p><code>METRIST_INSTANCE_ID</code></p><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">export</span><span style="color:#A6ACCD;"> METRIST_INSTANCE_ID=instance-name</span></span>
<span class="line"></span></code></pre></div><p>This is the instance id used for reporting. It can be any logical name, but <strong>should be unique and consistent between runs</strong>. Metrist will use this value to supply the instance with the date &amp; time of last monitor runs.</p><p>For example:</p><ul><li><p>We run monitors in several Azure, AWS, and GCP regions. Each Orchestrator instance is named accordingly: <code>us-west-1</code>, <code>us-east-2</code>, <code>az:canadacentral</code>, <em>etc</em>.</p></li><li><p>You may run Metrist Orchestrator in several offices, or departments, or servers; you can use these values to identify each instance.</p></li></ul><h3 id="orchestrator-run-groups" tabindex="-1">Orchestrator Run Groups <a class="header-anchor" href="#orchestrator-run-groups" aria-hidden="true">#</a></h3><p><code>METRIST_RUN_GROUPS</code></p><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">export</span><span style="color:#A6ACCD;"> METRIST_RUN_GROUPS=group_1,groupTwo,group-3</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;"># one item, or a comma-separated list</span></span>
<span class="line"></span></code></pre></div><p>The information defines one or more \u201Cgroups\u201D in which Orchestrator will \u201Crun\u201D/schedule your monitors.</p><p>For example:</p><ul><li><p>We may use these values to schedule all our AWS monitors in all our Orchestrator instances hosted at Azure. (<em>Yes</em>, we test across platforms in this way.) In the environments running Orchestrator on Azure\u2019s servers, our <code>METRIST_RUN_GROUPS</code> value may look like: <code>&quot;ca-central-1,us-east-1,us-east-2,us-west-1,us-west-2&quot;</code>.</p><p>Metrist then knows those Orchestrators are willing to run monitors configured for those run groups. (Learn to configure new monitors using our <a href="/tools/api.html">monitor config API</a>.)</p></li><li><p>You may have Metrist in-process agents (what we call <a href="/guides/download-overview.html#terminology">IPA monitors</a>) running throughout a backend system; and you may have other <a href="/guides/download-overview.html#terminology">synthetic monitors</a> running against all your API endpoints. You could, for example, run an Orchestrator for each set of monitors:</p><ul><li>In Orchestrator #1 <code>METRIST_RUN_GROUPS=all-our-in-process-monitors</code></li><li>In Orchestrator #2 <code>METRIST_RUN_GROUPS=all-our-endpoint-monitors</code></li><li>Even a 3rd Orchestrator to run them all: <code>METRIST_RUN_GROUPS=all-our-in-process-monitors,all-our-endpoint-monitors</code></li></ul></li></ul><h2 id="optional-orchestrator-behaviour" tabindex="-1">Optional: Orchestrator Behaviour <a class="header-anchor" href="#optional-orchestrator-behaviour" aria-hidden="true">#</a></h2><p>While these environment variables are optional, they can help control the behaviour of each Orchestrator instance.</p>`,23),f=t('<dt><code>METRIST_INSTANCE_ID</code></dt><dd><p>A string. (Usually, but not necessarily, <a href="https://textedit.tools/kebabcase" target="_blank" rel="noreferrer">kebab case</a>.)</p></dd><dd><p>This is the instance id used for reporting. It can be any logical name, but <strong>should be unique and consistent between runs</strong>. Metrist will use this value to supply the instance with the date &amp; time of last monitor runs.</p></dd><dt><code>METRIST_RUN_GROUPS</code></dt><dd><p>A string. (Usually, but not necessarily, <a href="https://textedit.tools/kebabcase" target="_blank" rel="noreferrer">kebab case</a>.)</p></dd><dd><p>The information defines one or more \u201Cgroups\u201D in which Orchestrator will \u201Crun\u201D/schedule your monitors. When more than one, a comma-separated list. This can be used to have several instances of Orchestrator run some same set of monitors.</p></dd><dt><code>METRIST_CLEANUP_ENABLED</code></dt><dd><p>Any string. (Empty means \u201Cdon\u2019t clean up\u201D.)</p></dd><dd><p>A flag that determines whether to run cleanup actions.</p></dd><dd><p>Some monitors produce artefacts as they run. For example, a monitor may create a database or download a file. Such monitors can have a \u201CCleanup\u201D action to clean up the artefacts produced during previous runs \u2014 this can occur when a monitor cannot remove the objects themselves (because of a crash or a provider outage, <em>etc</em>). As these operations can be expensive, it is best to only schedule them on a subset of instances.</p></dd><dt><code>METRIST_SECRETS_SOURCE</code></dt><dd><p><code>aws</code> (Or empty.)</p></dd><dd><p>When monitors need secrets like API keys or database passwords, this is a pointer to the secrets source. Currently only <code>aws</code> is supported (and is the default), which will try to retrieve secrets from AWS Secrets Manager.</p></dd>',13),g=e("code",null,"METRIST_CMA_CONFIG",-1),y=t("<dd><p>An agent configuration file. (Currently only used for in-process forwarding patterns.)</p></dd><dt><code>METRIST_LOGGING_LEVEL</code></dt><dd><p><code>Info</code> (Default) | <code>Debug</code> | <code>Error</code> | <code>Notice</code> | <code>Warning</code> | <code>Critical</code> | <code>Alert</code> | <code>Emergency</code></p></dd><dd><p>The level at which to log.</p></dd><dd><p>Usually the default is fine (<code>Info</code>) but sometimes <code>Debug</code> makes sense. <code>Error</code> can be used to make the process less talkative. <code>Notice</code>, <code>Warning</code>, <code>Critical</code>, <code>Alert</code> and <code>Emergency</code> are also accepted options don\u2019t make much difference and might not be supported by all monitors (each monitor may have specific interpretations of this variable).</p></dd><dt><code>METRIST_IPA_LOOPBACK_ONLY</code></dt><dd><p>Any string. (Empty by default.) (Anything but empty means \u201Copen the UDP socket <strong>only</strong> for the loopback/localhost address\u201D.)</p></dd><dd><p>Whether to open the UDP socket for in-process data <strong>only</strong> on the loopback/localhost address.</p></dd><dd><p>This can be used to restrict this sort of traffic to only the local machine. Off by default which means that the \u201Cwildcard\u201D address is bound, making the UDP socket accessible to all machines that can route to the instance.</p></dd>",9),b=e("h2",{id:"optional-monitor-configuration",tabindex:"-1"},[o("Optional: Monitor Configuration "),e("a",{class:"header-anchor",href:"#optional-monitor-configuration","aria-hidden":"true"},"#")],-1),v=e("p",null,"Monitors may each require their own, unique environment variables.",-1),T=e("p",null,[o("Refer to our "),e("a",{href:"/monitors/"},"Monitors Library"),o(" for examples.")],-1);function I(r,A,E,S,w,O){const a=h("Badge");return l(),i("div",null,[e("h1",u,[o(d(r.$frontmatter.title)+" ",1),m]),_,e("dl",null,[f,e("dt",null,[g,o(),c(a,{type:"warning",text:"beta"})]),y]),b,v,T])}const M=n(p,[["render",I]]);export{C as __pageData,M as default};
