import{_ as o,c as a,a as e,b as s,t as n,e as r,o as i}from"./app.d0dbe5e1.js";const _=JSON.parse('{"title":"Metrist Orchestrator","description":"","frontmatter":{"title":"Metrist Orchestrator"},"headers":[{"level":2,"title":"Orchestration","slug":"orchestration","link":"#orchestration","children":[]},{"level":2,"title":"In-process forwarding","slug":"in-process-forwarding","link":"#in-process-forwarding","children":[]},{"level":2,"title":"Configuration","slug":"configuration","link":"#configuration","children":[]}],"relativePath":"tools/orchestrator-source-code.md","lastUpdated":1669071708000}'),c={name:"tools/orchestrator-source-code.md"},l={id:"frontmatter-title",tabindex:"-1"},h=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),d=r(`<p>This repository contains Orchestrator, which performs two main functions:</p><ul><li>Orchestration of monitor runs.</li><li>Forwarding of in-process monitoring data it receives.</li></ul><p>The agent is written in Elixir and distributed both as a stand-alone executable and a container.</p><h2 id="orchestration" tabindex="-1">Orchestration <a class="header-anchor" href="#orchestration" aria-hidden="true">#</a></h2><p>Based on monitor configurations maintained on the Metrist backend, Orchestrator will schedule runs of checks for certain monitors. It is configured with an instance id that allows the backend to keep track of when something was last run and one or more &quot;run groups&quot; that allow the backend to decide what monitors and checks are configured to run on that particular instance of Orchestrator.</p><p>When a monitor is up for its run, it is downloaded from a Metrist-managed S3 bucket so that the latest version of a monitor is always executed; it is then started and the monitor is expected to participate in a simple <a href="https://github.com/Metrist-Software/orchestrator/blob/docs/protocol.md" target="_blank" rel="noreferrer">procotol</a> to exchange configuration data and have Orchestrator drive the monitoring code through the configured scenario. For every step, a timing is obtained and Orchestrator sends that back to the Metrist backend.</p><h2 id="in-process-forwarding" tabindex="-1">In-process forwarding <a class="header-anchor" href="#in-process-forwarding" aria-hidden="true">#</a></h2><p>Metrist Orchestrator comes with a handler for in-process monitoring. For every Metrist In-Process Agent (IPA) message it receives, it will try to match the messages against its configuration to see whether it needs to be forwarded to the Metrist backend.</p><p>IPA messages consist of four fields: the HTTP method, the url, the path, and the time it took for the HTTP transaction to complete. A configuration file can be specified by pointing the environment variable <code>METRIST_CMA_CONFIG</code> to a Yaml file with contents similar to this snippet:</p><div class="language-yaml"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki"><code><span class="line"><span style="color:#F07178;">patterns</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">braintree.Transaction</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">method</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">any</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">host</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">api.*.braintreegateway.com</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">url</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/transaction$</span></span>
<span class="line"></span></code></pre></div><p>You can specify as many patterns as you like. The key is in the format &quot;monitor-name.check-name&quot;, both of which you can obtain from our web UI. <code>method</code> and <code>url</code> can both be left out or for clarity specified as <code>&quot;any&quot;</code> in which case everything matches. All three fields are regular expressions that are matched against the corresponding fields in the IPA message. If it matches, the measured value will be sent to the Metrist backend.</p><h2 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-hidden="true">#</a></h2><p>Metrist Orchestrator is configured through environment variables:</p><ul><li><code>METRIST_INSTANCE_ID</code> - this is the instance id used for reporting. It can be any logical name, but should be unique and consistent between runs as the backend will use this to supply the instance with the timings of last monitoring runs.</li><li><code>METRIST_RUN_GROUPS</code> - one or more &quot;run groups&quot; this monitor will schedule. When more than one, a comma-separated list. This can be used to have several instances of monitors run some same set of monitors.</li><li><code>METRIST_CLEANUP_ENABLED</code> - if set, a flag that determines whether to run cleanup actions. Monitors can have a &quot;Cleanup&quot; action that usually is there to remove artefacts of previous runs which these runs could not remove themselves (because of a crash or a provider outage, for example). Because these operations can be expensive, it is best to only schedule them on a subset of instances.</li><li><code>METRIST_SECRETS_SOURCE</code> - when monitors need secrets like API keys, a pointer to the secrets source. Currently only &quot;aws&quot; is supported (and the default), which will try to retrieve secrets from AWS Secrets Manager.</li><li><code>METRIST_CMA_CONFIG</code> - the agent configuration file, currently only used for in-process forwarding patterns as described above.</li><li><code>METRIST_LOGGING_LEVEL</code> - the level to log at; usually the &quot;Info&quot; default is fine but sometimes &quot;Debug&quot; makes sense, and &quot;Error&quot; can be used to make the process less talkative. &quot;Notice&quot;, &quot;Warning&quot;, &quot;Critical&quot;, &quot;Alert&quot; and &quot;Emergency&quot; are also accepted options but will usually not make too much of a difference and might not be supported by all monitors that also interpret this variable.</li><li><code>METRIST_IPA_LOOPBACK_ONLY</code> - whether to open the UDP socket for in-process data only on the loopback/localhost address. This can be used to restrict this sort of traffic to only the local machine. Off by default which means that the &quot;wildcard&quot; address is bound, making the UDP socket accessible to all machines that can route to the instance.</li><li><code>METRIST_IPA_SERVER_PORT</code> - sets a port through which telemetry data is to be sent. The default is port 51712.</li></ul>`,14);function p(t,u,f,m,g,b){return i(),a("div",null,[e("h1",l,[s(n(t.$frontmatter.title)+" ",1),h]),d])}const w=o(c,[["render",p]]);export{_ as __pageData,w as default};
