import{_ as i,c as o,a as e,b as r,t as s,e as a,o as n}from"./app.dabbfae6.js";const b=JSON.parse('{"title":"General Documentation","description":"","frontmatter":{"title":"General Documentation"},"headers":[{"level":2,"title":"Overview","slug":"overview","link":"#overview","children":[]},{"level":2,"title":"Terminology","slug":"terminology","link":"#terminology","children":[]},{"level":2,"title":"Metrist Orchestrator","slug":"metrist-orchestrator","link":"#metrist-orchestrator","children":[{"level":3,"title":"Private synthetic monitoring","slug":"private-synthetic-monitoring","link":"#private-synthetic-monitoring","children":[]},{"level":3,"title":"In-process monitoring","slug":"in-process-monitoring","link":"#in-process-monitoring","children":[]}]}],"relativePath":"guides/download-overview.md","lastUpdated":1670289166000}'),c={name:"guides/download-overview.md"},h={id:"frontmatter-title",tabindex:"-1"},l=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),d=a('<h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-hidden="true">#</a></h2><p>This document explains how the various parts of Metrist\u2019s offering fit together \u2014 especially the shared code that is run on-premises.</p><h2 id="terminology" tabindex="-1">Terminology <a class="header-anchor" href="#terminology" aria-hidden="true">#</a></h2><ul><li><p><em>On-premises</em>, or \u201Con-prem\u201D, designates code that runs on customer owned or operated infrastructure and under a customer\u2019s control. While \u201Con-prem\u201D classically meant \u201Cat customer-owned sites\u201D like offices, factories and warehouses, we include any cloud infrastructure and co-location sites as well.</p></li><li><p><em>Shared code</em> is the code that Metrist shares with customers under NDA. We share this code so that customers can verify the safety of our code, create their own builds, and make their own extensions. All code that Metrist expects customers to run on-premises is shared.</p></li><li><p><em>Metrist backend</em> is the term we use for systems that are operated by Metrist on its infrastructure.</p></li><li><p><em>Monitor</em> is a process that actively assesses the availability and performance of an API, usually a vendor\u2019s API.</p></li><li><p><em>Synthetic monitor</em> is a monitor that uses \u201Cfake\u201D data to talk to the vendor API.</p></li><li><p><em>Production monitor</em> is a monitor that uses real production traffic to assess the availability and performance of an API. A production monitor typically observes production software to gather API performance data, currently typically done by in-process monitoring.</p></li><li><p><em>Monitors</em> (in our <a href="./../monitors/">Monitor Library</a>) are synthetic monitors that Metrist continuously runs on its own infrastructure, generating data that can be used by all customers.</p></li><li><p><em>Private monitors</em> are monitors that are operated, using Metrist-supplied software, by customers on their own infrastructure. Typically, private monitors use service-specific credentials for the APIs monitored that are managed by the customer.</p></li><li><p><em>Metrist Orchestrator</em> is software that customers run on-premises to execute private monitors. Orchestrator is also responsible for supporting in-process monitoring by collecting and pre-processing data sent to it by in-process monitoring.</p></li><li><p><em>In-process monitoring</em> is the act of intercepting API calls in production systems. Software that runs \u201Cinside\u201D the production code\u2019s processes sniffs out API calls and forwards them to the monitoring agent. The monitoring agent has logic to decide whether the intercepted API call has data that contributes to the assessment of a production monitor.</p></li></ul><h2 id="metrist-orchestrator" tabindex="-1">Metrist Orchestrator <a class="header-anchor" href="#metrist-orchestrator" aria-hidden="true">#</a></h2><p>Metrist Orchestrator is the cornerstone of our on-premises offering. Orchestrator has two main functions:</p><ol><li>To schedule and run private synthetic monitors. This is very much alike to how monitors are scheduled and run on the Metrist backend, but with a different, customer-specific configuration.</li><li>To receive data from in-process monitoring. The in-process part of this system is intentionally kept as simple as possible, to minimize the overhead and risk associated with \u201Cintruding\u201D on production code. The monitoring agent takes care of the heavy lifting here.</li></ol><h3 id="private-synthetic-monitoring" tabindex="-1">Private synthetic monitoring <a class="header-anchor" href="#private-synthetic-monitoring" aria-hidden="true">#</a></h3><p>Using an API key, Metrist Orchestrator fetches customer-specific scheduling configuration from the Metrist backend and uses that to decide which synthetic monitors to run. This happens roughly every ten seconds. For each monitor that is scheduled to run, Orchestrator will look at the last time the monitor reported back (again fetching this from the Metrist backend) and decide whether enough time has elapsed to warrant a new run of the monitor. If this is true, then the monitor is run. Measurements collected by the monitor are sent to the Metrist backend for further analysis.</p><p>The goals of private synthetic monitoring are three-fold:</p><ol><li><p>To provide insights how vendor APIs work from the customer\u2019s premises. Metrist\u2019s monitors run from a number of geographically distributed locations but these locations will not necessarily match where customer interactions with the vendor happens, and network issues often result in highly local outages.</p></li><li><p>To provide insights how vendor APIs react on the customer\u2019s exact data. Monitors run with \u201Cdummy\u201D data, often on vendor accounts dedicated to monitoring. It is likely that data sizes influence how a vendor API behaves, and as such using a production API key for monitoring may reveal different behaviour. By employing private monitoring, control of production API keys and production data can stay where it should be: on-premises.</p><p>Note that the monitor is still synthetic \u2014 it runs \u201Cfake\u201D transactions \u2014 but it operates on \u201Creal\u201D data, which can have a large performance impact.</p></li><li><p>To facilitate monitoring for vendor APIs that are not supported by Metrist. Using the shared source for Metrist Orchestrator, customers can build their own monitors and run them through the agent.</p></li></ol><p>Metrist Orchestrator comes bundled with all monitors that Metrist supports for private monitoring. It is the configuration document, however, that decides which monitors are run. By storing this configuration document centrally, multiple instances of the Orchestrator can run with the same configuration. By sending measurements back to the Metrist backend, measurements can be:</p><ul><li>aggregated,</li><li>compared with public measurements,</li><li>and trigger notifications in the same way notifications for monitors are triggered.</li></ul><h3 id="in-process-monitoring" tabindex="-1">In-process monitoring <a class="header-anchor" href="#in-process-monitoring" aria-hidden="true">#</a></h3><p>For certain production processes, Metrist supplies \u201CIn-Process Agents\u201D (IPAs) that intercept outgoing API calls (or, more often, outgoing HTTP calls). How this happens is dependent on the actual stack; two curent examples are:</p><ul><li><p><a href="/tools/agent-ruby-in-process.html">Ruby-on-Rails IPA</a>: Ruby has the concept of \u201Cmonkey-patching\u201D where new code can extend or override existing code. The agent overrides some code in <code>Net::HTTP</code>, the standard Ruby module for outgoing HTTP calls. It measures the timing of the request and sends some request data and timing off to Metrist Orchestrator for further processing.</p></li><li><p><a href="/tools/agent-php-in-process.html">PHP/Curl IPA</a>: PHP code normally uses Curl to make outgoing HTTP calls. Curl is integrated in most, if not all, PHP distributions. Our IPA, which is currently Linux-specific, uses the Linux dynamic linker\u2019s audit facility to be informed of any Curl calls, takes timings of the request, and sends request data and timing off to Metrist Orchestrator for further processing.</p></li></ul><p>More agents may follow, but they will all share the characteristics of the current agents:</p><ul><li><p>Minimal code and overhead. The agents run literally \u201Cinside\u201D production systems and therefore their footprint should be as small as possible. Code should be as small as possible to make verification as easy as possible.</p></li><li><p>Non-intrusive. We send the data to Metrist Orchestrator using UDP, which risks the loss of data but will make sure that the IPA never blocks or waits for the Orchestrator to be available. Whether the data arrives somewhere or not, the behaviour of the IPA code will not change.</p></li><li><p>Maximize out-of-band processing. The IPA is a firehose that simply sends off data of <em>all</em> intercepted calls to Metrist Orchestrator. Our Orchestrator can then take processing at leisure, sift out data it knows about, and convert it into a format that the Metrist backend requires. The data can be queued and processed with arbitrary delays as long as it is properly timestamped when received.</p></li></ul><p>Note that with this setup, customer-operated software is still in full control over what is sent to the Metrist backend. While the IPA typically operates in \u201Cfirehose\u201D mode, observing and forwarding all outgoing API calls to Metrist Orchestrator, it acts as a filter to send data that is clean, free of sensitive information, and expected to be sent to the Metrist backend.</p><h4 id="ipa-orchestrator-protocol" tabindex="-1">IPA/Orchestrator Protocol <a class="header-anchor" href="#ipa-orchestrator-protocol" aria-hidden="true">#</a></h4><p>Data flows from IPA to Orchestrator through UDP on port 51712 by default (this is configurable). As indicated above, UDP was chosen because of the \u201Cfire-and-forget\u201D characteristics of sending datagrams: there is no wait for acknowledgement, not even a check whether there is actually a process to receive them, so no chance that the sending process will block or otherwise delay. While data can be lost, we think it is a small consideration in exchange for predictable performance of the IPA.</p><p>Again, to keep the IPA code simple, the format that is expected is very trivial. Currently two formats are supported - the Ruby and PHP IPAs \u201Csee\u201D differently-formatted data and rather than burdening them with parsing or combining URL fragments, it is shipped \u201Cas is\u201D to Metrist Orchestrator so that the IPA code can stay as simple as possible. This trend may continue with more format variations to accomodate specific use cases.</p><p>An IPA message consists of fields, separated by tab characters (ASCII code 9) and terminated by line feeds (ASCII code 11). This format is simple to construct, simple to parse, and human readable. The first field is always a version code and it determines the rest of the payload. The current variants are:</p><ul><li>Version 0: four fields containing the HTTP method, host, path and time (in fractional milliseconds);</li><li>Version 1: three fields containing the HTTP method, URL, and time (in fractional milliseconds).</li></ul>',24);function m(t,u,p,f,g,y){return n(),o("div",null,[e("h1",h,[r(s(t.$frontmatter.title)+" ",1),l]),d])}const v=i(c,[["render",m]]);export{b as __pageData,v as default};
